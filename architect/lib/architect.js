// Generated by CoffeeScript 1.3.3
(function() {
  var Architect, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Architect = (function() {

    Architect.prototype.CANMORE_REQUEST_URL = '/';

    Architect.prototype.LAT_METERS = 100000;

    Architect.prototype.LONG_METERS = 70000;

    Architect.prototype.RADIUS = 400;

    Architect.prototype.DEFAULT_HEIGHT_SDU = 4.5;

    Architect.prototype.MIN_SCALING_DISTANCE = 50;

    Architect.prototype.DISTANCE_SCALE_LOG = 1.5;

    Architect.prototype.MIN_SCALING_FACTOR = 0.1;

    Architect.prototype.OFFSET_Y_RANDOM_FACTOR = 3;

    Architect.prototype.REQUEST_INTERVAL = 50;

    Architect.prototype.LOG_LEVEL = 2;

    function Architect(canmoreRequestUrl) {
      var _this = this;
      this.canmoreRequestUrl = canmoreRequestUrl || this.CANMORE_REQUEST_URL;
      this.lastLocation = new AR.GeoLocation(0, 0, 0);
      this.currentLocation = new AR.GeoLocation(0, 0, 0);
      this.photoGeoObjects = {};
      this.placemarkGeoObjects = {};
      this.imgResources = {};
      this.locationChangedFunc = null;
      this.mode = null;
      this.requestBuffer = [];
      this.timeSinceLastRequest = this.REQUEST_INTERVAL;
      this.objectsToLoad = 0;
      setInterval((function() {
        return _this.clearRequestBuffer();
      }), this.REQUEST_INTERVAL);
      this.request("status?loadedARview=true");
    }

    Architect.prototype.log = function(msg, level) {
      if (level == null) {
        level = 1;
      }
      if (level >= this.LOG_LEVEL) {
        return console.log(msg);
      }
    };

    Architect.prototype.request = function(msg) {
      return this.requestBuffer.push(msg);
    };

    Architect.prototype.clearRequestBuffer = function() {
      var report;
      report = this.requestBuffer.shift();
      if (report === void 0) {
        return;
      }
      return this.sendRequest(report);
    };

    Architect.prototype.sendRequest = function(msg) {
      return document.location = "architectsdk://" + msg;
    };

    Architect.prototype.setLocation = function(loc, lat, long, alt) {
      var _ref;
      return _ref = [lat, long, alt], loc.latitude = _ref[0], loc.longitude = _ref[1], loc.altitude = _ref[2], _ref;
    };

    Architect.prototype.setLastLocation = function(loc) {
      return this.setLocation(this.lastLocation, loc.latitude, loc.longitude, loc.altitude);
    };

    Architect.prototype.locationChanged = function(lat, long, alt, acc) {
      this.log("changing location to " + [lat, long].join(", "));
      this.setLocation(this.currentLocation, lat, long, alt);
      if (this.locationChangedFunc !== null) {
        return this.locationChangedFunc();
      }
    };

    Architect.prototype.setMode = function(mode, data) {
      if (data == null) {
        data = null;
      }
      this.log("setting mode " + mode);
      if (mode === this.mode) {
        return;
      }
      if (mode === "photo") {
        return this.setupPhotoMode();
      } else {
        return this.setupPlacemarkMode();
      }
    };

    Architect.prototype.setupPhotoMode = function() {
      this.log("setting up photo mode");
      this.locationChangedFunc = null;
      this.mode = 'photo';
      this.disablePlacemarks();
      this.enablePhotos();
      if (this.locationChangeSufficient() || this.empty(this.photoGeoObjects)) {
        this.cleanUpPhotos();
        this.updatePhotos();
      }
      return this.locationChangedFunc = this.maybeUpdatePhotos;
    };

    Architect.prototype.locationChangeSufficient = function() {
      return this.currentLocation.distanceTo(this.lastLocation) > this.RADIUS / 5;
    };

    Architect.prototype.maybeUpdatePhotos = function() {
      this.log("conditionally updating photos");
      if (this.locationChangeSufficient()) {
        this.setLastLocation(this.currentLocation);
        this.cleanUpPhotos();
        return this.updatePhotos();
      }
    };

    Architect.prototype.disablePhotos = function() {
      var id, photo, _ref, _results;
      this.log("disabling photos");
      _ref = this.photoGeoObjects;
      _results = [];
      for (id in _ref) {
        photo = _ref[id];
        _results.push(photo.enabled = false);
      }
      return _results;
    };

    Architect.prototype.enablePhotos = function() {
      var id, photo, _ref, _results;
      this.log("enabling photos");
      _ref = this.photoGeoObjects;
      _results = [];
      for (id in _ref) {
        photo = _ref[id];
        _results.push(photo.enabled = true);
      }
      return _results;
    };

    Architect.prototype.updatePhotos = function() {
      this.log("updating photos");
      return this.getPhotosForLocation(this.currentLocation);
    };

    Architect.prototype.cleanUpPhotos = function() {
      var distance, drawable, id, item, _ref, _results;
      this.log("cleaning up photos");
      _ref = this.photoGeoObjects;
      _results = [];
      for (id in _ref) {
        item = _ref[id];
        distance = this.currentLocation.distanceTo(item.locations[0]);
        this.log("Object " + id + " is " + distance + "m away");
        if (distance > this.RADIUS) {
          this.log("Destroying object " + id);
          _results.push(this.destroyGeoObject('photo', id));
        } else {
          this.log("Resetting opacity and scale on object " + id);
          _results.push((function() {
            var _i, _len, _ref1, _results1;
            _ref1 = item.drawables.cam;
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              drawable = _ref1[_i];
              _results1.push(this.setOpacityAndScaleOnDrawable(drawable, distance));
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    Architect.prototype.createPhotoGeoObject = function(siteId) {
      var _this = this;
      this.log("creating photoGeoObject for id " + siteId);
      if (this.photoGeoObjects[siteId] === void 0) {
        return this.serverRequest("details_for_site_id/", [siteId], function(siteDetails) {
          var location;
          _this.log("creating geoObject with loc " + siteDetails.lat + ", " + siteDetails.long + ": " + siteDetails.thumbs[0]);
          location = {
            lat: siteDetails.lat,
            long: siteDetails.long,
            alt: _this.currentLocation.altitude
          };
          return _this.createGeoObject(location, siteDetails.thumbs[0], siteId, 'photoGeoObjects');
        });
      }
    };

    Architect.prototype.getPhotosForLocation = function(loc) {
      var _this = this;
      this.log("getting photos for location " + loc.latitude + ", " + loc.longitude);
      return this.serverRequest("site_ids_for_location/", [loc.latitude, loc.longitude, this.RADIUS], function(siteIds) {
        var id, _i, _len, _results;
        _this.log("Found " + siteIds.length + " images", 2);
        _this.setObjectsToLoad(siteIds.length);
        _results = [];
        for (_i = 0, _len = siteIds.length; _i < _len; _i++) {
          id = siteIds[_i];
          _results.push(_this.createPhotoGeoObject(id));
        }
        return _results;
      });
    };

    Architect.prototype.setupPlacemarkMode = function() {
      this.log("setting up placemark mode");
      this.locationChangedFunc = null;
      this.mode = "placemark";
      if (this.empty(this.placemarkGeoObjects)) {
        this.requestPlacemarkData();
      }
      this.disablePhotos();
      this.enablePlacemarks();
      if (this.locationChangeSufficient()) {
        this.updatePlacemarks;
      }
      return this.locationChangedFunc = this.maybeUpdatePlacemarks;
    };

    Architect.prototype.requestPlacemarkData = function() {
      this.log("requesting placemark data");
      return this.request("requestplacemarkdata");
    };

    Architect.prototype.setPlacemarkData = function(data) {
      var details, id;
      this.log("setting placemark data");
      this.destroyPlacemarks();
      this.setObjectsToLoad(this.lengthOf(data));
      for (id in data) {
        details = data[id];
        this.createGeoObject(details.location, details.imgUri, id, "placemarkGeoObjects");
      }
      return this.log("created placemarks");
    };

    Architect.prototype.destroyPlacemarks = function() {
      var id, placemark, _ref, _results;
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        _results.push(this.destroyGeoObject("placemark", id));
      }
      return _results;
    };

    Architect.prototype.enablePlacemarks = function() {
      var id, placemark, _ref, _results;
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        _results.push(placemark.enabled = true);
      }
      return _results;
    };

    Architect.prototype.disablePlacemarks = function() {
      var id, placemark, _ref, _results;
      this.log("disabling placemarks");
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        this.log("disabling placemark " + id);
        _results.push(placemark.enabled = false);
      }
      return _results;
    };

    Architect.prototype.maybeUpdatePlacemarks = function() {
      this.log("conditionally updating placemarks");
      if (this.currentLocation.distanceTo(this.lastLocation) > this.RADIUS / 5) {
        this.setLastLocation(this.currentLocation);
        return this.updatePlacemarks();
      }
    };

    Architect.prototype.updatePlacemarks = function() {
      var distance, drawable, id, placemark, _ref, _results;
      this.log("updating placemarks");
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        distance = this.currentLocation.distanceTo(placemark.locations[0]);
        this.log("object " + id + " is " + distance + "m away");
        this.log("resetting opacity and scale on object " + id);
        _results.push((function() {
          var _i, _len, _ref1, _results1;
          _ref1 = placemark.drawables.cam;
          _results1 = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            drawable = _ref1[_i];
            _results1.push(this.setOpacityAndScaleOnDrawable(drawable, distance));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Architect.prototype.scalingFactor = function(distance) {
      var logVal;
      if (!(distance > this.MIN_SCALING_DISTANCE)) {
        return 1;
      }
      logVal = Math.log(distance / this.MIN_SCALING_DISTANCE) / Math.log(this.DISTANCE_SCALE_LOG);
      return Math.max(1 - (logVal / 10), this.MIN_SCALING_FACTOR);
    };

    Architect.prototype.setOpacityAndScaleOnDrawable = function(drawable, distance) {
      var scalingFactor;
      scalingFactor = this.scalingFactor(distance);
      drawable.scale = scalingFactor;
      return drawable.opacity = scalingFactor;
    };

    Architect.prototype.destroyGeoObject = function(type, id) {
      var collection, drawable, geo, location, _i, _j, _len, _len1, _ref, _ref1;
      if (type == null) {
        type = "photo";
      }
      this.log("destroying " + type + " geoObjects");
      collection = this["" + type + "GeoObjects"];
      geo = collection[id];
      _ref = geo.drawables.cam;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        drawable = _ref[_i];
        delete this.imgResources[drawable.imageResource.uri];
        drawable.imageResource.destroy();
        drawable.destroy();
      }
      _ref1 = geo.locations;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        location = _ref1[_j];
        location.destroy();
      }
      geo.destroy();
      return delete collection[id];
    };

    Architect.prototype.createGeoObject = function(location, imgUri, id, collectionName) {
      var collection, distance, drawable, drawableOptions, geoObject, imgRes,
        _this = this;
      this.log("creating geoObject " + id + " in collection " + collectionName);
      collection = this[collectionName];
      location = new AR.GeoLocation(location.lat, location.long, location.alt);
      distance = this.currentLocation.distanceTo(location);
      drawableOptions = {
        offsetY: (Math.random() * this.OFFSET_Y_RANDOM_FACTOR) - this.OFFSET_Y_RANDOM_FACTOR / 2,
        enabled: true
      };
      geoObject = new AR.GeoObject(location, {
        enabled: false
      });
      imgRes = this.createImageResource(imgUri, geoObject);
      drawable = this.createImageDrawable(imgRes, drawableOptions);
      drawable.triggers.onClick = function() {
        return _this.objectWasClicked(id, collectionName);
      };
      this.setOpacityAndScaleOnDrawable(drawable, distance);
      geoObject.drawables.addCamDrawable(drawable);
      return collection[id] = geoObject;
    };

    Architect.prototype.objectWasClicked = function(id, collection) {
      this.log("clicked " + id + ", " + collection);
      return this.request("clickedobject?id=" + id + "&collection=" + collection);
    };

    Architect.prototype.setObjectsToLoad = function(num) {
      this.objectsToLoad = num;
      return this.request("status?objectstoload=" + num);
    };

    Architect.prototype.createImageResource = function(uri, geoObject) {
      var imgRes,
        _this = this;
      if (this.imgResources[uri] !== void 0) {
        geoObject.enabled = true;
        this.setObjectsToLoad(--this.objectsToLoad);
        return this.imgResources[uri];
      }
      this.log("creating imageResource for " + uri);
      imgRes = new AR.ImageResource(uri, {
        onError: function() {
          return _this.log("error loading image " + uri);
        },
        onLoaded: function() {
          _this.setObjectsToLoad(--_this.objectsToLoad);
          if (!(imgRes.getHeight() === 109 && imgRes.getWidth() === 109)) {
            _this.log("loaded image " + uri);
            return geoObject.enabled = true;
          }
        }
      });
      this.imgResources[uri] = imgRes;
      return imgRes;
    };

    Architect.prototype.createImageDrawable = function(imgRes, options) {
      return new AR.ImageDrawable(imgRes, this.DEFAULT_HEIGHT_SDU, options);
    };

    Architect.prototype.serverRequest = function(url, params, callback) {
      var requestUrl;
      params || (params = []);
      requestUrl = this.canmoreRequestUrl + url + params.join('/') + '?callback=?';
      return $.getJSON(requestUrl, function(data) {
        return callback(data);
      });
    };

    Architect.prototype.empty = function(object) {
      var key, val;
      for (key in object) {
        val = object[key];
        return false;
      }
      return true;
    };

    Architect.prototype.lengthOf = function(object) {
      var count, key, val;
      count = 0;
      for (key in object) {
        val = object[key];
        count++;
      }
      return count;
    };

    return Architect;

  })();

  root.Canmore = {
    Architect: Architect
  };

}).call(this);
