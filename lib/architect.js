// Generated by CoffeeScript 1.3.3
(function() {
  var Architect, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Architect = (function() {

    Architect.prototype.DEFAULT_HEIGHT_SDU = 2.5;

    Architect.prototype.RADIUS = 300;

    Architect.prototype.MIN_SCALING_DISTANCE = 30;

    Architect.prototype.DISTANCE_SCALE_LOG = 1.7;

    Architect.prototype.MIN_SCALING_FACTOR = 0.1;

    Architect.prototype.OFFSET_Y_RANDOM_FACTOR = 2;

    Architect.prototype.REQUEST_INTERVAL = 50;

    Architect.prototype.LOG_LEVEL = 1;

    function Architect(canmoreRequestUrl) {
      var _this = this;
      this.lastLocation = new AR.GeoLocation(0, 0, 0);
      this.currentLocation = new AR.GeoLocation(0, 0, 0);
      this.photoGeoObjects = {};
      this.placemarkGeoObjects = {};
      this.imgResources = {};
      this.locationChangedFunc = null;
      this.mode = null;
      this.requestBuffer = [];
      this.timeSinceLastRequest = this.REQUEST_INTERVAL;
      setInterval((function() {
        return _this.clearRequestBuffer();
      }), this.REQUEST_INTERVAL);
      this.request("loadedARView");
    }

    Architect.prototype.log = function(msg, level) {
      if (level == null) {
        level = 1;
      }
      if (level >= this.LOG_LEVEL) {
        return console.log(msg);
      }
    };

    Architect.prototype.request = function(msg) {
      return this.requestBuffer.push(msg);
    };

    Architect.prototype.clearRequestBuffer = function() {
      var report;
      report = this.requestBuffer.shift();
      if (report === void 0) {
        return;
      }
      return this.sendRequest(report);
    };

    Architect.prototype.sendRequest = function(msg) {
      return document.location = "architectsdk://" + msg;
    };

    Architect.prototype.setLocation = function(loc, lat, long, alt) {
      var _ref;
      return _ref = [lat, long, alt], loc.latitude = _ref[0], loc.longitude = _ref[1], loc.altitude = _ref[2], _ref;
    };

    Architect.prototype.setLastLocation = function(loc) {
      return this.setLocation(this.lastLocation, loc.latitude, loc.longitude, loc.altitude);
    };

    Architect.prototype.locationChanged = function(lat, long, alt, acc) {
      this.log("changing location to " + [lat, long].join(", "));
      this.setLocation(this.currentLocation, lat, long, alt);
      if (this.locationChangedFunc !== null) {
        return this.locationChangedFunc();
      }
    };

    Architect.prototype.setMode = function(mode) {
      this.log("setting mode " + mode);
      if (mode === this.mode) {
        return;
      }
      if (mode === "photo") {
        return this.setupPhotoMode();
      } else if (mode === "placemark") {
        return this.setupPlacemarkMode();
      }
    };

    Architect.prototype.setupPhotoMode = function() {
      this.log("setting up photo mode");
      this.locationChangedFunc = null;
      this.mode = "photo";
      this.disablePlacemarks();
      this.enablePhotos();
      if (this.locationChangeSufficient() || this.empty(this.photoGeoObjects)) {
        this.cleanUpPhotos();
        return this.updatePhotos();
      }
    };

    Architect.prototype.locationChangeSufficient = function() {
      var distance;
      distance = this.currentLocation.distanceTo(this.lastLocation);
      this.log("distance from last location is " + distance);
      return distance > this.RADIUS / 5;
    };

    Architect.prototype.maybeUpdatePhotos = function() {
      this.log("conditionally updating photos");
      if (this.locationChangeSufficient()) {
        this.setLastLocation(this.currentLocation);
        this.cleanUpPhotos();
        return this.updatePhotos();
      }
    };

    Architect.prototype.disablePhotos = function() {
      var id, photo, _ref, _results;
      this.log("disabling photos");
      _ref = this.photoGeoObjects;
      _results = [];
      for (id in _ref) {
        photo = _ref[id];
        _results.push(photo.enabled = false);
      }
      return _results;
    };

    Architect.prototype.enablePhotos = function() {
      var id, photo, _ref, _results;
      this.log("enabling photos");
      _ref = this.photoGeoObjects;
      _results = [];
      for (id in _ref) {
        photo = _ref[id];
        _results.push(photo.enabled = true);
      }
      return _results;
    };

    Architect.prototype.updatePhotos = function() {
      this.log("updating photos");
      return this.requestPhotoData();
    };

    Architect.prototype.cleanUpPhotos = function() {
      var distance, drawable, id, item, _ref, _results;
      this.log("cleaning up photos");
      _ref = this.photoGeoObjects;
      _results = [];
      for (id in _ref) {
        item = _ref[id];
        distance = this.currentLocation.distanceTo(item.locations[0]);
        this.log("Object " + id + " is " + distance + "m away");
        if (distance > this.RADIUS) {
          this.log("Destroying object " + id);
          _results.push(this.destroyGeoObject("photo", id));
        } else {
          this.log("Resetting opacity and scale on object " + id);
          _results.push((function() {
            var _i, _len, _ref1, _results1;
            _ref1 = item.drawables.cam;
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              drawable = _ref1[_i];
              _results1.push(this.setOpacityAndScaleOnDrawable(drawable, distance));
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    Architect.prototype.requestPhotoData = function() {
      this.log("requesting photo data");
      return this.request("requestPhotoData.aos");
    };

    Architect.prototype.setPhotoData = function(data) {
      var details, id;
      this.log("setting photo data");
      this.cleanUpPhotos();
      for (id in data) {
        details = data[id];
        this.createGeoObject(details.site_name, details.location, details.imgUri, id, "photoGeoObjects");
      }
      return this.log("created photos");
    };

    Architect.prototype.setupPlacemarkMode = function() {
      this.log("setting up placemark mode");
      this.locationChangedFunc = null;
      this.mode = "placemark";
      if (this.empty(this.placemarkGeoObjects)) {
        this.requestPlacemarkData();
      }
      this.disablePhotos();
      this.enablePlacemarks();
      if (this.locationChangeSufficient()) {
        this.updatePlacemarks;
      }
      return this.locationChangedFunc = this.maybeUpdatePlacemarks;
    };

    Architect.prototype.requestPlacemarkData = function() {
      this.log("requesting placemark data");
      return this.request("requestPlacemarkData.aos");
    };

    Architect.prototype.setPlacemarkData = function(data) {
      var details, id;
      this.log("setting placemark data");
      this.destroyPlacemarks();
      for (id in data) {
        details = data[id];
        this.createGeoObject(details.site_name, details.location, details.imgUri, id, "placemarkGeoObjects");
      }
      return this.log("created placemarks");
    };

    Architect.prototype.destroyPlacemarks = function() {
      var id, placemark, _ref, _results;
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        _results.push(this.destroyGeoObject("placemark", id));
      }
      return _results;
    };

    Architect.prototype.enablePlacemarks = function() {
      var id, placemark, _ref, _results;
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        _results.push(placemark.enabled = true);
      }
      return _results;
    };

    Architect.prototype.disablePlacemarks = function() {
      var id, placemark, _ref, _results;
      this.log("disabling placemarks");
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        this.log("disabling placemark " + id);
        _results.push(placemark.enabled = false);
      }
      return _results;
    };

    Architect.prototype.maybeUpdatePlacemarks = function() {
      this.log("conditionally updating placemarks");
      if (this.locationChangeSufficient) {
        this.setLastLocation(this.currentLocation);
        return this.updatePlacemarks();
      }
    };

    Architect.prototype.updatePlacemarks = function() {
      var distance, drawable, id, placemark, _ref, _results;
      this.log("updating placemarks");
      _ref = this.placemarkGeoObjects;
      _results = [];
      for (id in _ref) {
        placemark = _ref[id];
        distance = this.currentLocation.distanceTo(placemark.locations[0]);
        this.log("object " + id + " is " + distance + "m away");
        this.log("resetting opacity and scale on object " + id);
        _results.push((function() {
          var _i, _len, _ref1, _results1;
          _ref1 = placemark.drawables.cam;
          _results1 = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            drawable = _ref1[_i];
            _results1.push(this.setOpacityAndScaleOnDrawable(drawable, distance));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Architect.prototype.scalingFactor = function(distance) {
      var logVal;
      if (!(distance > this.MIN_SCALING_DISTANCE)) {
        return 1;
      }
      logVal = Math.log(distance / this.MIN_SCALING_DISTANCE) / Math.log(this.DISTANCE_SCALE_LOG);
      return Math.max(1 - (logVal / 10), this.MIN_SCALING_FACTOR);
    };

    Architect.prototype.setOpacityAndScaleOnDrawable = function(drawable, distance) {
      var scalingFactor;
      scalingFactor = this.scalingFactor(distance);
      drawable.scale = scalingFactor;
      drawable.opacity = scalingFactor;
      return drawable.offsetY = drawable.origOffsetY * scalingFactor;
    };

    Architect.prototype.destroyGeoObject = function(type, id) {
      var collection, geo;
      if (type == null) {
        type = "photo";
      }
      this.log("destroying " + type + " geoObjects");
      collection = this["" + type + "GeoObjects"];
      geo = collection[id];
      this.log("disabling geoobject");
      geo.enabled = false;
      this.log("removing cam drawables");
      geo.drawables.cam = [];
      this.log("destroying geoobject");
      geo.destroy();
      this.log("deleting object from collection");
      return delete collection[id];
    };

    Architect.prototype.createGeoObject = function(siteName, location, imgUri, id, collectionName) {
      var collection, distance, drawableOptions, geoObject, imgDrawable, imgRes, label,
        _this = this;
      this.log("creating geoObject " + id + ", " + siteName + " in collection " + collectionName);
      collection = this[collectionName] || {};
      if (collection[id] !== void 0) {
        this.log("object already exists");
        return;
      }
      location = new AR.GeoLocation(location.lat, location.long, location.alt);
      distance = this.currentLocation.distanceTo(location);
      drawableOptions = {
        offsetY: (Math.random() * this.OFFSET_Y_RANDOM_FACTOR) - this.OFFSET_Y_RANDOM_FACTOR / 2,
        enabled: true
      };
      geoObject = new AR.GeoObject(location, {
        enabled: false
      });
      imgRes = this.createImageResource(imgUri, geoObject, collectionName);
      imgDrawable = this.createImageDrawable(imgRes, drawableOptions);
      imgDrawable.origOffsetY = imgDrawable.offsetY;
      imgDrawable.triggers.onClick = function() {
        return _this.objectWasClicked(id, collectionName);
      };
      this.setOpacityAndScaleOnDrawable(imgDrawable, distance);
      geoObject.drawables.addCamDrawable(imgDrawable);
      label = this.createLabel(siteName, drawableOptions);
      this.setOpacityAndScaleOnDrawable(label, distance);
      geoObject.drawables.addCamDrawable(label);
      return collection[id] = geoObject;
    };

    Architect.prototype.objectWasClicked = function(id, collection) {
      this.log("clicked " + id + ", " + collection);
      return this.request("clickedObject.aos?id=" + id + "&collection=" + collection);
    };

    Architect.prototype.createImageResource = function(uri, geoObject, collectionName) {
      var imgRes, mode,
        _this = this;
      this.log("creating imageResource for " + uri);
      mode = collectionName === "placemarkGeoObjects" ? "placemark" : "photo";
      imgRes = new AR.ImageResource(uri, {
        onError: function() {
          return _this.log("error loading image " + uri);
        },
        onLoaded: function() {
          if (!(imgRes.getHeight() === 109 && imgRes.getWidth() === 109)) {
            _this.log("loaded image " + uri + ", mode is " + _this.mode + "::" + mode);
            return geoObject.enabled = _this.mode === mode;
          }
        }
      });
      return imgRes;
    };

    Architect.prototype.createImageDrawable = function(imgRes, options) {
      return new AR.ImageDrawable(imgRes, this.DEFAULT_HEIGHT_SDU, options);
    };

    Architect.prototype.createLabel = function(text, options, distance) {
      var label;
      options.offsetY = options.offsetY - 1.75;
      options.style = {
        backgroundColor: "#ffffff"
      };
      label = new AR.Label(text, 0.6, options);
      label.origOffsetY = options.offsetY;
      return label;
    };

    Architect.prototype.empty = function(object) {
      var key, val;
      for (key in object) {
        val = object[key];
        return false;
      }
      return true;
    };

    Architect.prototype.lengthOf = function(object) {
      var count, key, val;
      count = 0;
      for (key in object) {
        val = object[key];
        count++;
      }
      return count;
    };

    return Architect;

  })();

  root.Canmore = {
    Architect: Architect
  };

}).call(this);
